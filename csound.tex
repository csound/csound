\documentclass[10pt,letterpaper,onecolumn]{ltxguide}
\usepackage{t1enc}
\usepackage{verbatim}
\usepackage[latin1]{inputenc}
\usepackage[english]{babel}
%% \usepackage{doc/latex/doxygen}
\pagestyle{headings}
\begin{document}

\title{Csound and CsoundVST}
\author{Michael Gogins \\ \texttt{gogins@pipeline.com}}
\maketitle

\abstract{This document explains how to download, build, install, extend, and use Csound and CsoundVST on Windows and Linux.}

\section{Introduction}

Csound is a unit-generator based, user-programmable computer music system. It was originally written by Barry Vercoe at the Massachusetts Institute of Technology in 1984 as the first C language version of this type of software. Since then Csound has received numerous contributions from researchers, programmers, and musicians around the world. 

Around 1991, John ffitch ported Csound to Microsoft DOS. Csound currently runs on many varieties of UNIX and Linux, Microsoft DOS and Windows, all versions of the Macintosh operating system including Mac OS X, and others.

Csound is maintained by John ffitch at \linebreak[4] \texttt{http://www.sourceforge.net/projects/csound}. Documentation for the Csound language is maintained by Kevin Conder at \linebreak[4] \texttt{http://kevindumpscore.com/}. Csound's ``home page'' is maintained by Richard Boulanger at \linebreak[3] \texttt{http://csounds.com}. 

There are newer computer music systems that have graphical patch editors (e.g. Max/MSP, PD, jMax, or Open Sound World), or that use more advanced techniques of software engineering (e.g. Nyquist or SuperCollider). But Csound still has the largest and most varied set of unit generators, is the best documented, runs on the most platforms, and is the easiest to extend. It is possible to compile Csound using double-precision arithmetic throughout for superior sound quality. In short, Csound must be considered one of the most powerful musical instruments ever created.

Csound development is ongoing, and currently stands at version 5 beta. New features in Csound 5 include the GNU Lesser General Public License, plugin unit generators, an application programming interface (API) for embedding Csound in other software, and the use of widely accepted third-party libraries for cross-platform development: libsndfile for reading and writing soundfiles, PortAudio for reading and writing digital audio from sound cards, and the Fast Light Tool Kit (FLTK) for graphics.

To create music with Csound:

\begin{enumerate}
\item Write an orchestra (\texttt{.orc} file) that creates instruments and signal processors by connecting unit generators (also called opcodes, in Csound-speak) using Csound's simple programming language.
\item Write a score (\texttt{.sco} file) that specifies a list of notes and other events to be rendered by the orchestra.
\item Run Csound to compile the orchestra and score, run the sorted and preprocessed score through the orchestra, and write digital audio out to a soundfile or sound card.
\end{enumerate}

CsoundVST is based on Csound, and adds a graphical user interface, C++ and Python APIs, Python scripting, a library of Python extension modules for algorithmic composition, a VST plugin interface, and a \emph{Mathematica} interface.

In addition to this ``canonical'' version of Csound and CsoundVST, there are other versions of Csound and other front ends for Csound, many of which can be found at \texttt{http://csounds.com}.

\section{Downloading}

Csound is hosted at \texttt{http:\-//www.sourceforge.net/projects/\-csound}. \linebreak Source and binary packages are available from the \texttt{files} link off that page.

The latest Csound source code is available through the Concurrent Versions System (CVS)(\texttt{http:\-//www.cvshome.org}). To download Csound sources using CVS, run the following commands:

\begin{verbatim}
cvs -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/csound login 
 
cvs -z3 -d:pserver:anonymous@cvs.sourceforge.net:/cvsroot/csound co csound5 
\end{verbatim}

Information about accessing the CVS repository may be found in the SourceForge document``Basic Introduction to CVS and SourceForge.net (SF.net) Project CVS Services''. 

If you wish to become a Csound developer, obtain a SourceForge login, and then apply to John ffitch at the \linebreak[3] \texttt{http:\-//www.sourceforge.net/projects/\-csound} site.

\section{Building}

Csound and CsoundVST are built using the Python package \texttt{scons}, not with makefiles or GNU autotools. Experience shows that \texttt{scons} build systems are easier to write, easier to use, and run faster than autotools build systems. The only file used to build the entire Csound system is the \texttt{SConstruct} file, which is a Python script run by the \texttt{scons} shell script.

To build Csound 5:
\begin{enumerate}
\item Obtain the Csound source code from a SourceForge Csound 5 package file, or from SourceForge CVS.
\item Install and configure the following software packages:
\begin{enumerate}
\item Python (required) for running the build (also used for CsoundVST scripting), from \linebreak[3] \texttt{http:\-//www.python.org}.
\item SCons (required) for running the build, from \linebreak[4] \texttt{http:\-//www.scons.org}.
\item libsndfile (required) for reading and writing soundfiles, from \linebreak[4] \texttt{http://www.mega-nerd.com/libsndfile/}.
\item PortAudio for reading and writing real-time audio, from \linebreak[4] \texttt{http://www.portaudio.com/}.
\item FLTK version 1.1.x for displaying graphs of function tables, and for widget opcodes, from \linebreak[3] \texttt{http://www.fltk.org}.
\end{enumerate}
\end{enumerate}
If you also want to build CsoundVST, you will need in addition:
\begin{enumerate}
\item The Software Interface and Wrapper Generator (SWIG) for generating Python interfaces to CsoundVST (required for CsoundVST), from \linebreak[3] \texttt{http://www.swig.org}.
\item The boost C++ template libraries for random numbers and linear algebra (required for CsoundVST), from \linebreak[4] \texttt{http://www.boost.org}.
\end{enumerate}
\subsection{Platforms}
Currently, Csound 5 builds and runs on Windows using either the Cygwin environment (\texttt{http://www.cygwin.com}), or the MinGW \linebreak[4] (\texttt{http://www.mingw.org}) environment with the MSys shell \linebreak[4] (\texttt{http://www.mingw.org/msys.shtml}). Both of these environments are free, open source, and emulate the standard Unix/Linux environment and tools. On Linux, Csound 5 builds using the standard tools. Unix should work the same way as Linux.

On Windows, the Cygwin build procedure is more like the Linux one. However, the MinGW build is preferred, since the resulting executables do not require the Cygwin DLLs and run faster.

\subsubsection{Linux}

For CsoundVST, you must configure the FLTK libraries to enable threads (\texttt{./configure ---enable-threads}).

If you have properly installed all the dependencies mentioned above, you can build Csound 5 and CsoundVST simply by opening a console, changing to the \texttt{csound5} directory, and executing the \texttt{scons} command. To see the various configuration options, execute \texttt{scons -h}.

\subsubsection{Windows with Cygwin}

The build procedure for Cygwin is identical to Linux. However, Cygwin comes with its own customized version of Python, while CsoundVST uses the regular version of Python from \texttt{http://www.python.org}, which is built with Microsoft Visual C++. Make sure to install SCons in the Cygwin version of Python, and use that version for the build, even though CsoundVST will use the Windows version of Python.

\subsubsection{Windows with MinGW and MSys}

For MinGW, you may need to patch SCons as follows. Change line 51 of \texttt{SCons/Tool/mingw.py} from:
\begin{verbatim}
cmd = SCons.Util.CLVar('$SHLINK', '$SHLINKFLAGS')
\end{verbatim}
to:
\begin{verbatim}
cmd = SCons.Util.CLVar(['$SHLINK', '$SHLINKFLAGS']) 
\end{verbatim}

It is highly recommend that you update your MinGW installation from the SourceForge site to the ``current'' level for core gcc, g++, binutils,  utils, and the Windows API headers and libraries.(w32api).

Rebuild and install a version of libsndfile no earlier than:
\begin{verbatim}
http://www.mega-nerd.com/tmp/libsndfile-1.0.10pre4.tar.gz
\end{verbatim}

For PortAudio, I have found that \texttt{./configure ---with-winapi=wmme} works and other \texttt{configure} options do not. If you can build PortAudio version 19 with DirectX and MinGW, please let me know how to do it.

The build procedure for MinGW is similar, but not identical, to the Cygwin procedure. The MSys shell does not allow the user to execute Python commands directly. Therefore, you need to install the \emph{Windows} versions of Python and SCons, make sure that Python is in your Windows executable path, and run the build like this:
\begin{verbatim}
$ python c:/tools/python23/scripts/scons
\end{verbatim}

You will also need to customize the \texttt{custom.py} file to declare to \texttt{scons} the locations of required header files and libraries, since on Windows there is no standard location for these as there is on Unix and Linux.

\section{Installing}

Once you have either unpacked a binary distribution, or built Csound from sources, you will need to install and configure Csound so that it will run properly on your system. 

\subsection{Csound}

Consult the Csound language documentation for instructions on how to install and configure Csound.

On Windows, make sure that the \texttt{windows\_dlls} directory is in your \texttt{PATH} environment variable, or else copy the files in it to your Windows \texttt{system32} directory. 

\subsection{CsoundVST}
CsoundVST requires some additional configuration:
\begin{enumerate}
\item Make sure that the Csound executables are in your \texttt{PATH} environment variable. 
\item On Windows, make sure the directory containing the \texttt{\_CsoundVST.dll} file and all the Csound plugin opcodes is also in your \texttt{PATH} variable. On Unix and Linux, make sure that the directory containing the \texttt{\_CsoundVST.so} file and all the Csound plugin opcodes is in your \texttt{LD\_LIBRARY\_PATH} environment variable. This variable may have a different name in different operating systems.
\item On all platforms, the directory containing the \texttt{\_CsoundVST} shared library and the \texttt{CsoundVST.py} file must be in your \texttt{PYTHONPATH} environment variable, so that the Python runtime knows how to load these files.
\end{enumerate}

\section{Extending}
Csound uses plugin unit generators. These are dynamic link libraries (DLLs) on Windows, and loadable modules (shared libraries that are \texttt{dlopen}ed) on Linux. It is relatively easy to extend Csound by writing new unit generators in C or C++.

The following assumes you already know how to make a regular Csound unit generator. If you don't, consult the Csound language documentation.
Supposing that your unit generator is named \texttt{xxx}, perform the following steps:
\begin{enumerate}
\item Write your \texttt{xxx.c} and \texttt{xxx.h} file as you would for a regular Csound unit generator. Put these files in the \texttt{csound5/Opcodes} directory.
\item \texttt{\#include "csdl.h"} in your unit generator sources. This causes the plugin development environment to emulate the regular Csound unit generator development environment.
\item Add your \texttt{OENTRY} records and unit generator registration functions at the bottom of your C file. Example (but you can have as many unit generators in one plugin as you like):
\begin{verbatim}
\#define S sizeof

static OENTRY localops[] = {
{ "xxx", S(XXX), 5, "a", "ao", (SUBR)xxxset, NULL, (SUBR)xxx}
};

/*
 * The following macro from csdl.h defines 
 * the "opcode_size()" and "opcode_init()" 
 * opcode registration functions for the localops table.
 */
LINKAGE
\end{verbatim}
\item Add your plugin as a new target in the plugin opcodes section of the \texttt{SConstruct} build file:
\begin{verbatim}
pluginEnvironment.SharedLibrary('xxx', 
    Split('''Opcodes/xxx.c 
    Opcodes/another_file_used_by_xxx.c 
    Opcodes/yet_another_file_used_by_xxx.c'''))
\end{verbatim}
\item Run the Csound 5 build in the regular way.
\end{enumerate}		

\section{Using}

Assuming that you have installed and configured the software, Csound and CsoundVST can be operated in a variety of modes and configurations. The \texttt{.csd} and \texttt{.py} files in the \texttt{examples} demonstrate a few of these modes of operation. Some of these scores are simple, others are moderately complex. 

You may need to edit the \texttt{----opcode-lib} option in the Csound command in some of the  \texttt{.csd} and \texttt{.py} files to match your environment. Similarly, you may need to edit the SoundFont file paths in instrument definitions that use the \texttt{fluid} SoundFont 2 player opcode to match your environment.

For real-time audio output, with or without MIDI control, you will probably want to tune the \texttt{kr} and \texttt{ksmps} orchestra statements, and the \texttt{-b} and \texttt{-B} command-line options, to give you the shortest possible latency that does not cause clicks or stutters in Csound's audio output. For example, with the Windows multimedia library build of the PortAudio library, \texttt{sr = 44100}, \texttt{kr = 441}, \texttt{ksmps = 100}, \texttt{-b100} and \texttt{-B2000} give a CD-equivalent audio sampling rate of 44,100 frames per second, a control sampling rate of 441 control samples per second with 100 audio sample frames per control sample, an audio output software buffer size of 100 sample frames, and an audio output device hardware buffer size of 2,000 sample frames, which yields an audio output latency of about 45 milliseconds --- not fast enough for precise and expressive keyboard playing, but fast enough for smooth control of effects or algorithmically generated or triggered scores.

On Linux with ALSA, the audio output device should be selected using a special form of the \texttt{-odac} option, for example \texttt{-odac:plughw:0} for device 0. The \texttt{plughw} option translates Csound's audio output to the format expected by the sound card. With ALSA, latencies of a few milliseconds are possible, and expressive real-time instrumental performance should be quite feasible.

\subsection{Csound}

\subsubsection{The \texttt{csound} Command}

The original method for running Csound was as a console program. This, of course, still works. Running \texttt{csound} without any arguments prints out a list of command-line options, which are more fully explained in the Csound language documentation. Normally, the user executes something like \texttt{csound -W -omysoundfile myorchestra.orc myscore.sco} or, to use the single-file Csound structured data (\texttt{.csd}) format, \texttt{csound myscore.csd}.

Csound can read and write soundfiles (off-line rendering), read and write digital audio using a sound card (real-time rendering), read and write MIDI files, and read and write MIDI using a MIDI interface and controller (real-time control). See the Csound language documentation for more details. 

\subsubsection{The Csound API}

The Csound API consists of the Csound library (\texttt{libcsound.a}) and the Csound header file (\texttt{csound.h}). You can build Csound into your own software very easily using this API. For example, the Csound command itself is made this way:

\begin{verbatim}
#include "csound.h"

int main(int argc, char **argv)
{
    // Create Csound.
    void *csound = csoundCreate(0);
    // One complete performance cycle.
    int result = csoundCompile(csound, argc, argv);
    if(!result)
    {
        while(csoundPerformKsmps(csound) == 0){}
        csoundCleanup(csound);
    }
    // Destroy Csound.
    csoundDestroy(csound);
    return result;
}
\end{verbatim}

\subsection{CsoundVST}

CsoundVST is a multi-function front end for the Csound API. CsoundVST runs as a stand-alone graphical user interface to Csound, or as a VST plugin in hosts such as the Cubase audio sequencer. CsoundVST provides both a C++ and a Python API to Csound, and to a set of classes for algorithmic composition. 

CsoundVST contains a built-in Python interpreter. With Python, the user can generate a score, import a MIDI file, process notes, load and run a Csound orchestra, and in general do anything that can be done either with Csound or in Python.

You must define the \texttt{PYTHONPATH} environment variable to include the directory containing the \texttt{\_CsoundVST} shared library and \texttt{CsoundVST.py} script.

\subsubsection{Standalone}

To run CsoundVST as a stand-alone front end to Csound, execute \texttt{CsoundVST}. When the program has loaded, you will see a graphical user interface with a row of buttons along the top. Click on the \emph{Open...} button to load a \texttt{.csd} file. You can also click on the \emph{Open...} button and load a \texttt{.orc} file, then click on the \emph{Import...} button to add a \texttt{.sco} file. You can edit the Csound command, the orchestra file, or the score file in the respective tabs of the user interface. When all is satisfactory, click on the \emph{Perform} button to run Csound. You can stop a performance at any time by clicking on the \emph{Stop} button.

\subsubsection{The CsoundVST API}

CsoundVST extends the Csound API with C++. There is a C++ class for the Csound API proper, another C++ class for manipulating Csound files in code, and additional classes for algorithmic composition based on music space. All these C++ classes also have a Python interface in the \texttt{CsoundVST} Python extension module. For more information, consult the Doxygen-generated files in the \texttt{csound5/doc} directory.

You can build CsoundVST into your own software using the \texttt{\_CsoundVST} shared library and \texttt{CsoundVST.hpp} header file. For example, the CsoundVST stand-alone graphical user interface program is made this way:

\begin{verbatim}
#include <CsoundVST.hpp>
#include <CsoundVstFltk.hpp>

int main(int argc, char **argv)
{
    CsoundVST *csoundVST = CreateCsoundVST();
    AEffEditor *editor = csoundVST->getEditor();
    editor ->open(0);
    return 0;
}
\end{verbatim}

There is also a high-level C API for CsoundVST, declared in \linebreak[4] \texttt{frontends/CsoundVST/csoundvst\_api.h}. Any program able to interface with C calling convention functions can use this API. For example, a \textbf{\emph{Mathematica}} 5.0 notebook can use the .NET/Link package's \texttt{DefineDLLFunction} to access the CsoundVST API to create an instance of CsoundVST, load an orchestra, generate a score using the power of \textbf{\emph{Mathematica}}, and render that score.

\subsubsection{Python scripting}

You can use CsoundVST as a Python extension module. In fact, you can do this either in a standard Python interpreter, such as Python command line or the Idle Python GUI, or in CsoundVST itself in Python mode.

To use CsoundVST in a standard Python interpreter, import CsoundVST.
\begin{verbatim}
import CsoundVST
\end{verbatim}

Create an instance of CppSound, which provides an object-oriented interface to the Csound API. 
\begin{verbatim}
csound = CsoundVST.CppSound()
\end{verbatim}

In a standard Python interpreter, run your script in the normal way. You can load a Csound \texttt{.csd} file and perform it: 

To use CsoundVST itself as your Python interpreter, click on the CsoundVST Settings tab, and select the Python check box in the Csound performance mode box. Do not create a new CppSound object; CsoundVST contains a built-in CppSound object that you must use. 

The \texttt{koch.py} script shows how to use Python to do algorithmic composition for Csound. You can use Python triple-quoted string literals to hold your Csound files right in your script, and assign them to Csound: 

\begin{verbatim}
csound.setOrchestra('''sr = 44100
kr = 441
ksmps = 100   
nchnls = 2
0dbfs = .1
instr 1,2,3,4,5 ; FluidSynth General MID
I; INITIALIZATION
; Channel, bank, and program determine the preset, that is, the actual sound.
ichannel		=			p1
iprogram		=			p6
ikey	 		= 			p4
ivelocity 		= 			p5 + 12
ijunk6 			= 			p6
ijunk7			=			p7
; AUDIO
istatus			=			144;			
print			iprogram, istatus, ichannel, ikey, ivelocityaleft, aright		
fluid			"c:/projects/csound5/samples/VintageDreamsWaves-v2.sf2", \\
    iprogram, istatus, ichannel, ikey, ivelocity, 1			
outs 			aleft, arightendin''')
csound.setCommand("csound --opcode-lib=c:/projects/csound5/fluid.dll \\
    -RWdfo ./koch.wav ./temp.orc ./temp.sco")
csound.exportForPerformance()
csound.perform()
\end{verbatim}

To run your script in Csound VST, click on the Perform button. 

\subsubsection{VST Plugin}
The following instructions are for Cubase SX. You would follow roughly similar procedures in other hosts.

Use the \emph{Devices} menu, \emph{Plug-In Information} dialog, \emph{VST Plug-Ins} tab, \emph{Shared VST Plug-ins Folder} text field to add your \texttt{csound5} directory to Cubase's plugin path. You can have multiple directories separated by semicolons. 

Quit Cubase, and start it again. 

Use the \emph{File} menu, \emph{New Project} dialog to create a new song. 

Use the \emph{Project} menu, \emph{Add Track} submenu, to add a new MIDI track. 

Use the pencil tool to draw a \emph{Part} on the track a few measures long. Write some music in the \emph{Part} using the \emph{Event} editor or the \emph{Score} editor. 

Use the \emph{Devices} menu (or the F11 key) to open the \emph{VST Instruments} dialog. 

Click on one of the \emph{No VST Instrument} labels, and select \emph{\_CsoundVST} from the list that pops up. 

Click on the \emph{e} (for edit) button to open the \emph{\_CsoundVST} dialog. 

Click on the \emph{Open} button to bring up the file selector dialog. Navigate to a directory containing a Csound csd file suitable for MIDI performance, such as csound/CsoundVST/examples/CsoundVST.csd. Click on the OK button to load the file. You can also open and import a suitable \texttt{.orc} and \texttt{.sco} file as described above. 

Click on the \emph{VST Instruments} dialog's on/off button to turn it on. This should compile the Csound orchestra. \emph{Note: If you don't compile the orchestra, you won't be able to assign the plugin to a track.} 

In the \emph{Cubase Track Inspector}, click on the \emph{out: Not Assigned} label and select \emph{\_CsoundVST} from the list that pops up. 

On the ruler at the top of the \emph{Arrangement} window, select the loop end point and drag it to the end of your part, then click on the loop button to enable looping. 

Click on the \emph{play} button on the \emph{Transport} bar. You should hear your music played by CsoundVST. 

Try assigning your track to different channels; a different Csound instrument will perform each channel. 

When you save your song, your Csound orchestra will be saved as part of the song and re-loaded when you re-load the song. 

You can click on the \emph{Orchestra} tab and edit your Csound instruments while CsoundVST is playing. To hear your changes, just click on the CsoundVST \emph{Perform} button to recompile the orchestra. 

You can assign up to 16 channels to a single CsoundVST plugin. However, you can't have more than one CsoundVST plugin in the same song! 
\section{Licenses}
\subsection{Csound and CsoundVST}
Csound is \copyright 1991-2003 by Barry Vercoe and John ffitch.

CsoundVST is \copyright 2001-2004 by Michael Gogins.

Csound and CsoundVST are free software; you can redistribute them and/or modify them under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version.

Csound and CsoundVST are distributed in the hope that they will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License along with Csound and CsoundVST; if not, write to the Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA.
\subsection{Virtual Synthesis Technology}
Virtual Synthesis Technology (VST) PlugIn interface technology by Steinberg Soft- und Hardware GmbH. 

CsoundVST source code contains modified versions of source code files from the VST SDK distributed by Steinberg. \emph{These files are to be used only for building CsoundVST.} You are \emph{not} licensed to use these files for any other purpose. If you make a derived product based on CsoundVST or the modified VST source files herein, you \emph{must} apply to Steinberg for your own license to use the VST SDK.
\section{Contributors}
Csound contains contributions from musicians, scientists, and programmers from around the world. They include (but are not limited to): 
\begin{itemize}
\item Allan Lee 
\item Barry Vercoe
\item Bill Gardner 
\item Bill Verplank 
\item Dan Ellis 
\item David Macintyre 
\item Eli Breder 
\item Gabriel Maldonado  
\item Greg Sullivan 
\item Hans Mikelson 
\item Istvan Varga 
\item Jean Piché 
\item John ffitch 
\item John Ramsdell 
\item Marc Resibois 
\item Mark Dolson 
\item Matt Ingalls 
\item Max Mathews 
\item Michael Casey 
\item Michael Clark 
\item Michael Gogins 
\item Mike Berry 
\item Paris Smaragdis 
\item Perry Cook 
\item Peter Neubäcker 
\item Peter Nix 
\item Rasmus Ekman 
\item Richard Dobson 
\item Richard Karpen 
\item Rob Shaw 
\item Robin Whittle 
\item Sean Costello 
\item Steven Yi 
\item Tom Erbe 
\item Victor Lazzarini  
\item Ville Pulkki 
\end{itemize}

\section{To Do}

This is a ``to do'' list, not necessarily complete, for Csound and CsoundVST:

\begin{enumerate}
\item In preparation for a beta file release package:
\item Complete this document sufficiently to get users started building and running Csound and CsoundVST with MinGW and Linux.
\item Get MIDI input and output working better on Windows (that is, a lower latency for PortAudio).
\item Longer term:
\item Gabriel's Python opcodes.
\item The Loris plugin opcodes.
\item The ATS opcodes.
\item The STK plugin opcodes.
\item Investigate the Python runtime situation on MinGW.
\end{enumerate}

\end{document}